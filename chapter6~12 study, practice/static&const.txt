Const

const를 변수에 사용시 선언할 때 초기화를 제외하고 값을 바꿀수 없다
const상수는 어떤값을 보호하기위해 사용되어진다.
const int * pN1 = &n1;
*pN1 = 20--> 값을 바꿀수 없음, 주소는 변경가능.위치주의
int const * pN2 = &n1;
pN2 = &n2-->주소값을 바꿀수 없음, 값은 변경가능.위치주의

const 멤버변수 사용시 멤버 이니셜라이즈 사용:id(_id)

const 멤버함수
주소로 접근하여 수정하는 것을 인식못함.
상속받는 클래스의 객체와 상속하는 멤버변수는 상관이 없는것같음.
>>그 클래스안의 맴버변수만 해당하는것 같음!
멤버 변수의 값 변경을 허용하지않는다(for문의 i 같이 지역변수는 상관없다)
멤버  변수 값의 변경에 대한 기회제공도 불가(주소리턴을 허용하지 않는다. 컴파일에러)
리턴의 자료형도 const를 사용하면 리턴이 가능하다!!
어떤함수가 const함수이면 그안에 포함된 함수도 const이어야한다.
const도 함수 오버로딩 조건에 포함
그래서 const 멤벼변수이면 const함수 전용 showdata를 오버로딩해야함 

const 객체
데이터변경이 허용되지 않는 객체
const함수 이외에는 호출 불가

 
Static정적변수

클래스에서 전역변수와 전역함수를 일부 대체하기위해서 등장.
클래스는 캡슐화 특성상 모든 것을 클래스 안에서 하는것이 좋음.
>>스태틱멤버변수 사용.
모든객체가 공유할 수 있는 멤버.
static변수는 왜 다른멤버변수 초기화같이 초기값을 바로선언하면안될까?
전역의 공간에 왜 따로 초기화?? 멤버 이니셜라이즈도 안됨.
클래스 변수, 클래스 함수라고 하기도 함
main함수 호출이전에 메모리공간에올라가서 초기화
 static 멤버 초기화문으로 초기화해야 함
메모리: 데이터영역에 해당 프로그램종료시 소멸

Explicit&Mutable

explicit명시적 호출만 허용
mutable const에 예외를 둔다-사용안하는것이 좋다
