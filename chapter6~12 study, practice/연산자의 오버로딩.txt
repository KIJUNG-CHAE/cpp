연산자의 오버로딩

전역함수에의한 연산자 오버로딩은 멤버함수에 의한 오버로딩보다 인자를 하나더 추가해야됨
>>클래스 안에서 받는 멤버변수를 바로 못받아오기때문.
연산자의 우선순위와 결합성은 유지된다.
디폴트 매개변수 설정이 불가능하다 리턴값에 추가로 숫자를 더하기힘듦
리턴에 클래스의 래퍼런스를 사용함으로 해당 객체를 바로 수정가능
이경우 해당객체를 리턴해야하기때문에 *this사용
이렇게 참조를 이용하여 리턴하는경우는 지역객체를 리턴하면 안된다. 그값을가져다쓰기때문에
사라지면 곤란!
래퍼런스를 쓰지않으면 클래스의 객체를 바로 리턴하면된다.
리턴을 클래스로 받는경우 리턴값에*this를 쓴다면 복사본이리턴된다.
이는 객체의 값은 변하지만 매시행마다 객체의 복사본이 복사생성자로 일시적으로 생겼다가
사라졌다를 반복하기때문에 좋은 방법이아니다.
//클래스안에서 멤버함수형식으로 정의된 연산자 함수 객체가 되는값이 그 클래스의 객체이어야한다
만약 주인공이 클래스타입이 아닌 것이온다면 전역함수를이용해 클래스의 객체로 리턴해줘야함
>>p2 = 3 +p1>>교환법칙?!간단하게 리턴값을 객체가 주인공이되게 바꾸면된다(자리 바꾸기)
연산자오버로딩에서 리턴타입이 클래스객체일경우 임시객체나 함수에서 해당클래스를 초기화하여
선언한뒤 리턴.

선연산과 후연산의 구분
클래스 래퍼런스 연산자오버로딩에서 인자값을 int로 주면 후연산
void로 두면 선연산을 한다
전역함수의 경우 클래스 래퍼런스,int값
//자기자신을 리턴할 필요가없는경우, p2 = p1 + 3 이런경우에서는클래스객체로 리턴함

임시객체는 만들어졌다 바로사라진다>> 잠시 전달할때 사용 ex)함수의 리턴.

ifstream, ofstream
해당 클래스가 존재하여 이미 생성된 cout객체,cin이라는 객체를 사용하는것
가져다쓰는 클래스에는 오버로딩이되어있다
리턴타입에 레퍼런스를 주게되면 추가로 객체가생성되지않고 자기자신을 이용하여
계속사용가능
*this로 리턴을 하게 되면 연속으로 <<,>>을사용가능하다

디폴트 대입연산자
캐릭터포인터로 대입연산을 시도하면 그주소값을 복사하기때문에 얕은복사가됨,
이를 극복하기위해 대입연산자를 오버로딩하여 주소를가리키는것이아닌 깊은복사를 할수있다.
깊은복사를하는 대입연산자는 & , *this사용, 다만 문자열일 경우,대입전 문자열값을 없애주고
다시 길이를 설정해준뒤 strcpy를 이용해 자기자신을 리턴해주면된다. 변하는값이아니므로const사용!!

연산자 오버로딩에서 
인자를 클래스의 객체로 쓸때 주인공이 아닌 객체는 const 단 ifstream 제외.